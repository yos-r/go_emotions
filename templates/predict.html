{% extends "base.html" %}

{% block title %}Predict Emotions - GoEmotions{% endblock %}

{% block content %}
<!-- Page Header -->
<div class="page-header">
    <h1><i class="fas fa-brain"></i> Predict Emotions</h1>
    <p>Enter text and see emotion predictions from all trained models</p>
</div>

<!-- Input Section -->
<div class="content-section">
    <h4 class="section-title">
        <i class="fas fa-keyboard"></i> Enter Your Text
    </h4>

                    <form id="predictionForm">
                        <div class="mb-3">
                            <label for="inputText" class="form-label">Text to Analyze:</label>
                            <textarea
                                class="form-control"
                                id="inputText"
                                rows="4"
                                placeholder="Type or paste a comment here... (e.g., 'I'm so happy and excited about this amazing news!')"
                                required
                            ></textarea>
                            <div class="form-text">
                                Enter any text to classify its emotions. The system will predict which of the 28 emotions are present.
                            </div>
                        </div>

                        <div class="mb-3">
                            <button type="submit" class="btn btn-primary btn-lg">
                                <i class="fas fa-magic"></i> Predict Emotions
                            </button>
                            <button type="button" class="btn btn-secondary btn-lg" id="exampleBtn">
                                <i class="fas fa-lightbulb"></i> Load Example
                            </button>
                        </div>
                    </form>

                    <!-- Loading Spinner -->
                    <div class="loading" id="loading">
                        <div class="spinner"></div>
                        <p class="mt-3">Analyzing emotions...</p>
                    </div>

    <!-- Results Container -->
    <div id="results" style="display: none;">
</div>

<div id="resultsSection" class="content-section" style="display: none;">
    <h4 class="section-title">
        <i class="fas fa-chart-pie"></i> Prediction Results
    </h4>

                        <!-- Model Tabs -->
                        <ul class="nav nav-pills mb-3" id="modelTabs" role="tablist">
                            {% for model in models %}
                            <li class="nav-item" role="presentation">
                                <button
                                    class="nav-link {% if loop.first %}active{% endif %}"
                                    id="{{ model }}-tab"
                                    data-bs-toggle="pill"
                                    data-bs-target="#{{ model }}-content"
                                    type="button"
                                    role="tab"
                                >
                                    {{ model|upper }}
                                </button>
                            </li>
                            {% endfor %}
                        </ul>

                        <!-- Model Results -->
                        <div class="tab-content" id="modelTabContent">
                            {% for model in models %}
                            <div
                                class="tab-pane fade {% if loop.first %}show active{% endif %}"
                                id="{{ model }}-content"
                                role="tabpanel"
                            >
                                <div class="card">
                                    <div class="card-body">
                                        <h5 class="card-title">{{ model|upper }} Model Predictions</h5>

                                        <div class="row">
                                            <div class="col-md-6">
                                                <h6>Detected Emotions (Above Threshold):</h6>
                                                <div id="{{ model }}-predicted" class="mb-3"></div>

                                                <p class="text-muted">
                                                    <small>Threshold: <span id="{{ model }}-threshold"></span></small>
                                                </p>
                                            </div>

                                            <div class="col-md-6">
                                                <h6>Top 5 Emotions by Probability:</h6>
                                                <div id="{{ model }}-top"></div>
                                            </div>
                                        </div>

                                        <div class="mt-4">
                                            <h6>All Emotion Scores:</h6>
                                            <div id="{{ model }}-chart"></div>
                                        </div>

                                        <!-- Explainability Section -->
                                        <div class="mt-4">
                                            <h6><i class="fas fa-lightbulb"></i> Explainability & Interpretation:</h6>
                                            <div class="card bg-light">
                                                <div class="card-body">
                                                    <div id="{{ model }}-attention" class="mb-3">
                                                        <strong>Word Importance Heatmap:</strong>
                                                        <div id="{{ model }}-word-importance" class="mt-2"></div>
                                                        <p class="text-muted small mt-2">
                                                            <i class="fas fa-info-circle"></i> Words highlighted in red had more influence on the predictions.
                                                            This visualization shows which parts of your text the model focused on.
                                                        </p>
                                                    </div>

                                                    <div id="{{ model }}-key-phrases" class="mt-3">
                                                        <strong>Key Influential Phrases:</strong>
                                                        <div id="{{ model }}-phrases-list" class="mt-2"></div>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            {% endfor %}
                        </div>

    <!-- LSTM Embedding Comparison -->
    <div class="card mt-4" id="lstmEmbeddingCard" style="display: none;">
        <div class="card-header">
            <i class="fas fa-layer-group"></i> LSTM Embedding Type Comparison
        </div>
        <div class="card-body">
            <p class="text-muted">Comparing predictions across different LSTM embedding strategies:</p>
            <div id="lstmEmbeddingComparison"></div>
        </div>
    </div>

    <!-- Comparison -->
    <div class="card mt-4">
        <div class="card-header">
            <i class="fas fa-balance-scale"></i> Model Comparison
        </div>
        <div class="card-body">
            <div class="table-responsive">
                <div id="comparisonTable"></div>
            </div>
        </div>
    </div>

    <!-- Model Agreement Analysis -->
    <div class="card mt-4">
        <div class="card-header">
            <i class="fas fa-microscope"></i> Model Agreement & Confidence Analysis
        </div>
        <div class="card-body">
            <div id="agreementAnalysis"></div>

            <div class="mt-4">
                <h6><i class="fas fa-info-circle"></i> Interpretation Guide:</h6>
                <div class="alert alert-info">
                    <ul class="mb-0">
                        <li><strong>High Agreement (All models agree):</strong> Strong confidence in the prediction</li>
                        <li><strong>Partial Agreement (Some models agree):</strong> Moderate confidence, nuanced emotions present</li>
                        <li><strong>Low Agreement (Models disagree):</strong> Text may contain mixed emotions or ambiguous content</li>
                        <li><strong>Confidence Bars:</strong> Green = high confidence, Yellow = moderate, Red = low confidence</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_css %}
<style>
    .word-importance {
        display: inline-block;
        padding: 2px 4px;
        margin: 2px;
        border-radius: 3px;
        transition: all 0.3s;
    }

    .word-importance:hover {
        transform: scale(1.1);
        z-index: 10;
    }

    .phrase-badge {
        display: inline-block;
        padding: 0.5rem 1rem;
        margin: 0.3rem;
        border-radius: 20px;
        background: linear-gradient(135deg, #3498db, #2980b9);
        color: white;
        font-size: 0.9rem;
        font-weight: 500;
    }

    .confidence-indicator {
        display: inline-block;
        width: 100px;
        height: 8px;
        background: #ecf0f1;
        border-radius: 4px;
        overflow: hidden;
        margin-left: 0.5rem;
    }

    .confidence-bar {
        height: 100%;
        background: linear-gradient(90deg, #e74c3c, #f39c12, #2ecc71);
        transition: width 0.3s;
    }

    /* Make comparison table scrollable */
    .table-responsive {
        max-height: 600px;
        overflow-x: auto;
        overflow-y: auto;
    }

    .table-responsive table {
        min-width: 100%;
    }

    /* Sticky header for comparison table */
    .table-responsive thead th {
        position: sticky;
        top: 0;
        background-color: white;
        z-index: 10;
        box-shadow: 0 2px 2px -1px rgba(0, 0, 0, 0.1);
    }

    /* Sticky first column */
    .table-responsive td:first-child,
    .table-responsive th:first-child {
        position: sticky;
        left: 0;
        background-color: white;
        z-index: 5;
        box-shadow: 2px 0 2px -1px rgba(0, 0, 0, 0.1);
    }

    .table-responsive thead th:first-child {
        z-index: 15;
    }
</style>
{% endblock %}

{% block extra_js %}
<script>
    const exampleTexts = [
        "I'm so happy and excited about this amazing news!",
        "This is absolutely disgusting and makes me angry.",
        "I'm really confused and not sure what to think about this.",
        "Thank you so much for your help! I really appreciate it.",
        "I'm feeling sad and disappointed about how things turned out.",
        "This is hilarious! I can't stop laughing!",
        "I'm so nervous about the presentation tomorrow.",
        "Wow, this is surprising! I didn't expect that at all."
    ];

    // Load example text
    $('#exampleBtn').click(function() {
        const randomText = exampleTexts[Math.floor(Math.random() * exampleTexts.length)];
        $('#inputText').val(randomText);
    });

    // Handle form submission
    $('#predictionForm').submit(function(e) {
        e.preventDefault();

        const text = $('#inputText').val().trim();
        if (!text) {
            alert('Please enter some text');
            return;
        }

        // Show loading, hide results
        $('#loading').show();
        $('#results').hide();

        // Make API call
        $.ajax({
            url: '/api/predict',
            method: 'POST',
            contentType: 'application/json',
            data: JSON.stringify({ text: text }),
            success: function(data) {
                displayResults(data);
                $('#loading').hide();
                $('#resultsSection').show();
            },
            error: function(xhr) {
                alert('Error: ' + (xhr.responseJSON?.error || 'Unknown error'));
                $('#loading').hide();
            }
        });
    });

    // Store current predictions globally for embedding switching
    let currentPredictions = {};
    let currentText = '';

    function displayResults(data) {
        currentPredictions = data;
        currentText = $('#inputText').val();

        const emotionColors = {
            'admiration': '#1976d2', 'amusement': '#f57c00', 'anger': '#c62828',
            'annoyance': '#c2185b', 'approval': '#388e3c', 'caring': '#7b1fa2',
            'confusion': '#f9a825', 'curiosity': '#00796b', 'desire': '#ad1457',
            'disappointment': '#5d4037', 'disapproval': '#d84315', 'disgust': '#303f9f',
            'embarrassment': '#b71c1c', 'excitement': '#f57f17', 'fear': '#4e342e',
            'gratitude': '#2e7d32', 'grief': '#455a64', 'joy': '#f9a825',
            'love': '#c2185b', 'nervousness': '#512da8', 'optimism': '#0277bd',
            'pride': '#558b2f', 'realization': '#e65100', 'relief': '#689f38',
            'remorse': '#bf360c', 'sadness': '#37474f', 'surprise': '#f57f17',
            'neutral': '#546e7a'
        };

        for (const [modelName, modelData] of Object.entries(data)) {
            // Skip variant models - they'll be accessed via selectors
            if (modelName.startsWith('lstm_') || modelName.startsWith('hybrid_')) {
                continue;
            }

            // Add variant selector for LSTM model
            if (modelName === 'lstm') {
                const embeddingSelector = $(`
                    <div class="alert alert-info mb-3">
                        <h6><i class="fas fa-layer-group"></i> Try Other Embeddings:</h6>
                        <p class="mb-2 small">Compare predictions with different embedding strategies:</p>
                        <div class="btn-group btn-group-sm" role="group" id="lstm-embedding-selector">
                            <button type="button" class="btn btn-outline-primary active" data-embedding="lstm">
                                Learned (Current)
                            </button>
                            <button type="button" class="btn btn-outline-primary lstm-predict-embedding-btn" data-embedding="lstm_fasttext">
                                FastText
                            </button>
                            <button type="button" class="btn btn-outline-primary lstm-predict-embedding-btn" data-embedding="lstm_glove">
                                GloVe
                            </button>
                        </div>
                    </div>
                `);
                $(`#${modelName}-content .card-body`).prepend(embeddingSelector);
            }

            // Add variant selector for CNN-BiLSTM model
            if (modelName === 'cnn_bilstm_attention') {
                const variantSelector = $(`
                    <div class="alert alert-primary mb-3" id="ablation-study-selector">
                        <h6><i class="fas fa-flask"></i> Explore Ablation Study Variants:</h6>
                        <p class="mb-2 small">Test different architectural configurations:</p>

                        <!-- Ablation Type Buttons -->
                        <div class="mb-3">
                            <label class="form-label small mb-2"><strong>Ablation Category:</strong></label>
                            <div class="btn-group-vertical d-block" role="group" id="predict-ablation-type-buttons">
                                <button type="button" class="btn btn-sm btn-outline-primary active mb-1" data-ablation="cnn_bilstm_attention">
                                    <i class="fas fa-layer-group"></i> Full Model (Current)
                                </button>
                                <button type="button" class="btn btn-sm btn-outline-primary mb-1" data-ablation="attention">
                                    <i class="fas fa-brain"></i> Attention Variants
                                </button>
                                <button type="button" class="btn btn-sm btn-outline-primary mb-1" data-ablation="components">
                                    <i class="fas fa-cubes"></i> CNN/LSTM Components
                                </button>
                                <button type="button" class="btn btn-sm btn-outline-primary mb-1" data-ablation="embeddings">
                                    <i class="fas fa-font"></i> Embedding Types
                                </button>
                                <button type="button" class="btn btn-sm btn-outline-primary mb-1" data-ablation="regularization">
                                    <i class="fas fa-balance-scale"></i> Regularization
                                </button>
                            </div>
                        </div>

                        <!-- Specific Variants (will be populated dynamically) -->
                        <div id="predict-variant-buttons-container" style="display: none;">
                            <label class="form-label small mb-2"><strong>Select Variant:</strong></label>
                            <div id="predict-variant-buttons" class="d-grid gap-2">
                                <!-- Variant buttons will be inserted here -->
                            </div>
                        </div>
                    </div>
                `);
                $(`#${modelName}-content .card-body`).prepend(variantSelector);

                // Load hybrid variants for the selector
                loadHybridVariantsForPredict();
            }
            // Predicted emotions
            const predictedDiv = $(`#${modelName}-predicted`);
            predictedDiv.empty();

            if (modelData.predicted_emotions.length === 0) {
                predictedDiv.append('<p class="text-muted">No emotions detected above threshold</p>');
            } else {
                modelData.predicted_emotions.forEach(emotion => {
                    const score = modelData.all_scores[emotion];
                    const color = emotionColors[emotion] || '#666';
                    predictedDiv.append(`
                        <span class="emotion-tag" style="background-color: ${color}20; color: ${color}; border: 2px solid ${color};">
                            ${emotion} (${(score * 100).toFixed(1)}%)
                        </span>
                    `);
                });
            }

            // Threshold
            $(`#${modelName}-threshold`).text(modelData.threshold);

            // Top 5 emotions
            const topDiv = $(`#${modelName}-top`);
            topDiv.empty();
            const topList = $('<ul class="list-group"></ul>');

            Object.entries(modelData.top_emotions).forEach(([emotion, score]) => {
                const color = emotionColors[emotion] || '#666';
                topList.append(`
                    <li class="list-group-item d-flex justify-content-between align-items-center">
                        <span>${emotion}</span>
                        <span class="badge rounded-pill" style="background-color: ${color};">
                            ${(score * 100).toFixed(2)}%
                        </span>
                    </li>
                `);
            });
            topDiv.append(topList);

            // All emotions chart
            const emotions = Object.keys(modelData.all_scores);
            const scores = Object.values(modelData.all_scores);
            const colors = emotions.map(e => emotionColors[e] || '#666');

            const trace = {
                x: emotions,
                y: scores,
                type: 'bar',
                marker: { color: colors }
            };

            const layout = {
                title: 'All Emotion Probabilities',
                xaxis: { tickangle: -45 },
                yaxis: { title: 'Probability', range: [0, 1] },
                height: 400
            };

            Plotly.newPlot(`${modelName}-chart`, [trace], layout);

            // Word importance visualization with LIME
            visualizeWordImportanceWithLIME(modelName, modelData);
        }

        // Comparison table
        createComparisonTable(data);

        // LSTM embedding comparison (only show if we have multiple LSTM models loaded)
        displayLSTMEmbeddingComparisonPrediction(data);

        // Add event handlers for LSTM embedding switching using delegation
        // Attach to body so it persists even when content is rebuilt
        $('body').off('click', '#lstm-embedding-selector button').on('click', '#lstm-embedding-selector button', function() {
            const embeddingModel = $(this).data('embedding');
            switchLSTMEmbedding(embeddingModel);
        });
    }

    function switchLSTMEmbedding(embeddingModel) {
        // Update active button
        $('#lstm-embedding-selector button').removeClass('active');
        $(`#lstm-embedding-selector button[data-embedding="${embeddingModel}"]`).addClass('active');

        // Show loading indicator in the LSTM tab
        const lstmContent = $('#lstm-content .card-body');
        const originalContent = lstmContent.html();
        lstmContent.html(`
            <div class="text-center py-5">
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
                <p class="mt-3 text-muted">Loading ${embeddingModel} predictions...</p>
            </div>
        `);

        console.log(`[Frontend] Requesting prediction for ${embeddingModel}`);

        // Make API call to get predictions for this specific embedding model only
        $.ajax({
            url: '/api/predict',
            method: 'POST',
            contentType: 'application/json',
            data: JSON.stringify({ text: currentText, model: embeddingModel }),
            success: function(data) {
                console.log(`[Frontend] Received prediction for ${embeddingModel}`);
                // Restore original content structure
                lstmContent.html(originalContent);

                if (data[embeddingModel]) {
                    updateLSTMDisplay(embeddingModel, data[embeddingModel]);
                } else {
                    alert(`Model ${embeddingModel} not available`);
                }
            },
            error: function(xhr) {
                console.error(`[Frontend] Error loading ${embeddingModel}:`, xhr);
                // Restore original content
                lstmContent.html(originalContent);
                alert('Error: ' + (xhr.responseJSON?.error || 'Unknown error'));
            }
        });
    }

    function updateLSTMDisplay(modelName, modelData) {
        const emotionColors = {
            'admiration': '#1976d2', 'amusement': '#f57c00', 'anger': '#c62828',
            'annoyance': '#c2185b', 'approval': '#388e3c', 'caring': '#7b1fa2',
            'confusion': '#f9a825', 'curiosity': '#00796b', 'desire': '#ad1457',
            'disappointment': '#5d4037', 'disapproval': '#d84315', 'disgust': '#303f9f',
            'embarrassment': '#b71c1c', 'excitement': '#f57f17', 'fear': '#4e342e',
            'gratitude': '#2e7d32', 'grief': '#455a64', 'joy': '#f9a825',
            'love': '#c2185b', 'nervousness': '#512da8', 'optimism': '#0277bd',
            'pride': '#558b2f', 'realization': '#e65100', 'relief': '#689f38',
            'remorse': '#bf360c', 'sadness': '#37474f', 'surprise': '#f57f17',
            'neutral': '#546e7a'
        };

        // Update the LSTM tab content with new embedding results
        // Update predicted emotions
        const predictedDiv = $('#lstm-predicted');
        predictedDiv.empty();

        if (modelData.predicted_emotions.length === 0) {
            predictedDiv.append('<p class="text-muted">No emotions detected above threshold</p>');
        } else {
            modelData.predicted_emotions.forEach(emotion => {
                const score = modelData.all_scores[emotion];
                const color = emotionColors[emotion] || '#666';
                predictedDiv.append(`
                    <span class="emotion-tag" style="background-color: ${color}20; color: ${color}; border: 2px solid ${color};">
                        ${emotion} (${(score * 100).toFixed(1)}%)
                    </span>
                `);
            });
        }

        // Update threshold
        $('#lstm-threshold').text(modelData.threshold);

        // Update top 5 emotions
        const topDiv = $('#lstm-top');
        topDiv.empty();
        const topList = $('<ul class="list-group"></ul>');

        Object.entries(modelData.top_emotions).forEach(([emotion, score]) => {
            const color = emotionColors[emotion] || '#666';
            topList.append(`
                <li class="list-group-item d-flex justify-content-between align-items-center">
                    <span>${emotion}</span>
                    <span class="badge rounded-pill" style="background-color: ${color};">
                        ${(score * 100).toFixed(2)}%
                    </span>
                </li>
            `);
        });
        topDiv.append(topList);

        // Update chart
        const emotions = Object.keys(modelData.all_scores);
        const scores = Object.values(modelData.all_scores);
        const colors = emotions.map(e => emotionColors[e] || '#666');

        const trace = {
            x: emotions,
            y: scores,
            type: 'bar',
            marker: { color: colors }
        };

        const layout = {
            title: 'All Emotion Probabilities',
            xaxis: { tickangle: -45 },
            yaxis: { title: 'Probability', range: [0, 1] },
            height: 400
        };

        Plotly.newPlot('lstm-chart', [trace], layout);

        // Update word importance
        visualizeWordImportanceWithLIME(modelName, modelData);

        // Update current predictions and refresh comparison
        currentPredictions[modelName] = modelData;
        createComparisonTable(currentPredictions);
        displayLSTMEmbeddingComparisonPrediction(currentPredictions);
    }

    function visualizeWordImportanceWithLIME(modelName, modelData) {
        const text = $('#inputText').val();
        const wordImportanceDiv = $(`#${modelName}-word-importance`);
        const phrasesDiv = $(`#${modelName}-phrases-list`);

        // Show loading state
        wordImportanceDiv.html('<p class="text-muted"><i class="fas fa-spinner fa-spin"></i> Generating LIME explanation...</p>');
        phrasesDiv.html('');

        // Skip BERT for now (needs different handling)
        if (modelName === 'bert') {
            wordImportanceDiv.html('<p class="text-muted">LIME explanation not available for BERT model</p>');
            return;
        }

        // Call LIME API
        $.ajax({
            url: '/api/explain',
            method: 'POST',
            contentType: 'application/json',
            data: JSON.stringify({ text: text, model: modelName }),
            success: function(limeData) {
                displayLIMEExplanation(modelName, limeData, modelData);
            },
            error: function(xhr) {
                console.error(`LIME explanation failed for ${modelName}:`, xhr.responseText);
                wordImportanceDiv.html('<p class="text-danger"><i class="fas fa-exclamation-triangle"></i> LIME explanation unavailable. Please try again.</p>');
            }
        });
    }

    function displayLIMEExplanation(modelName, limeData, modelData) {
        const wordImportanceDiv = $(`#${modelName}-word-importance`);
        const phrasesDiv = $(`#${modelName}-phrases-list`);
        const topEmotionDiv = $(`#${modelName}-key-phrases`);

        // Use LIME word importance scores
        const wordImportance = limeData.word_importance;
        const words = limeData.text.split(/\s+/);

        // Get top predicted emotion scores from LIME
        const topEmotions = Object.entries(modelData.all_scores)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 3);

        // Normalize scores to 0-1 range for visualization
        const scores = words.map(word => wordImportance[word] || 0);
        const maxScore = Math.max(...scores, 0.001);
        const normalizedScores = scores.map(s => s / maxScore);

        // Create LIME-based word heatmap
        const wordElements = words.map((word, idx) => {
            const score = normalizedScores[idx];
            const intensity = Math.floor(score * 255);
            const backgroundColor = `rgba(255, ${255 - intensity}, ${255 - intensity}, ${0.3 + score * 0.5})`;
            const textColor = score > 0.7 ? '#fff' : '#333';

            return `<span class="word-importance" style="background-color: ${backgroundColor}; color: ${textColor};"
                         title="LIME Importance: ${(score * 100).toFixed(0)}%">${word}</span>`;
        }).join(' ');

        wordImportanceDiv.html(wordElements + '<p class="text-success small mt-2"><i class="fas fa-check-circle"></i> Powered by LIME (Local Interpretable Model-agnostic Explanations)</p>');

        // Extract key phrases from LIME explanation
        const limeExplanations = limeData.lime_explanation.explanations;
        const keyPhrases = new Set();

        for (const [emotion, expData] of Object.entries(limeExplanations)) {
            // Get words with positive importance
            expData.word_weights.forEach(([phrase, weight]) => {
                if (Math.abs(weight) > 0.1) {  // Significant weight
                    keyPhrases.add(phrase);
                }
            });
        }

        if (keyPhrases.size > 0) {
            phrasesDiv.empty();
            Array.from(keyPhrases).slice(0, 8).forEach(phrase => {
                phrasesDiv.append(`<span class="phrase-badge">${phrase}</span>`);
            });
        } else {
            phrasesDiv.html('<p class="text-muted small">No strongly influential phrases detected by LIME</p>');
        }

        // Add top emotion indicators with LIME predictions
        topEmotionDiv.prepend(`
            <div class="mb-3">
                <strong>Top Detected Emotions (LIME Analysis):</strong>
                <div class="mt-2">
                    ${topEmotions.map(([emotion, score]) => {
                        const limeScore = limeData.lime_explanation.base_predictions[emotion] || score;
                        return `
                        <div class="d-flex align-items-center mb-2">
                            <span class="badge bg-primary" style="width: 120px;">${emotion}</span>
                            <div class="confidence-indicator">
                                <div class="confidence-bar" style="width: ${limeScore * 100}%"></div>
                            </div>
                            <span class="ms-2 small">${(limeScore * 100).toFixed(1)}%</span>
                        </div>
                    `}).join('')}
                </div>
                <p class="text-muted small mt-2">
                    <i class="fas fa-info-circle"></i> LIME generates explanations by perturbing the input and observing model behavior changes.
                </p>
            </div>
        `);
    }


    function createComparisonTable(data) {
        const comparisonDiv = $('#comparisonTable');
        comparisonDiv.empty();

        // Get all unique emotions across all models
        const allEmotions = new Set();
        Object.values(data).forEach(modelData => {
            modelData.predicted_emotions.forEach(e => allEmotions.add(e));
        });

        if (allEmotions.size === 0) {
            comparisonDiv.append('<p class="text-muted">No emotions detected by any model</p>');
            return;
        }

        const table = $('<table class="table table-bordered table-hover"></table>');
        const thead = $('<thead><tr><th>Emotion</th></tr></thead>');

        // Add model columns
        Object.keys(data).forEach(model => {
            thead.find('tr').append(`<th>${model.toUpperCase()}</th>`);
        });
        table.append(thead);

        const tbody = $('<tbody></tbody>');

        // Add rows for each emotion
        Array.from(allEmotions).sort().forEach(emotion => {
            const row = $(`<tr><td><strong>${emotion}</strong></td></tr>`);

            Object.values(data).forEach(modelData => {
                const score = modelData.all_scores[emotion];
                const isPredicted = modelData.predicted_emotions.includes(emotion);
                const cellClass = isPredicted ? 'table-success' : '';
                row.append(`<td class="${cellClass}">${(score * 100).toFixed(2)}%</td>`);
            });

            tbody.append(row);
        });

        table.append(tbody);
        comparisonDiv.append(table);

        // Generate agreement analysis
        analyzeModelAgreement(data);
    }

    function analyzeModelAgreement(data) {
        const agreementDiv = $('#agreementAnalysis');
        agreementDiv.empty();

        // Get all predicted emotions across models
        const emotionAgreement = {};
        const modelCount = Object.keys(data).length;

        Object.values(data).forEach(modelData => {
            modelData.predicted_emotions.forEach(emotion => {
                if (!emotionAgreement[emotion]) {
                    emotionAgreement[emotion] = {
                        count: 0,
                        scores: [],
                        models: []
                    };
                }
                emotionAgreement[emotion].count++;
                emotionAgreement[emotion].scores.push(modelData.all_scores[emotion]);
                emotionAgreement[emotion].models.push(
                    Object.keys(data).find(m => data[m] === modelData)
                );
            });
        });

        // Calculate overall agreement metrics
        const totalPredictions = Object.values(emotionAgreement).reduce((sum, e) => sum + e.count, 0);
        const unanimousEmotions = Object.entries(emotionAgreement).filter(([_, e]) => e.count === modelCount);
        const partialEmotions = Object.entries(emotionAgreement).filter(([_, e]) => e.count > 1 && e.count < modelCount);
        const singleEmotions = Object.entries(emotionAgreement).filter(([_, e]) => e.count === 1);

        // Create agreement summary
        const summaryHtml = `
            <div class="row text-center mb-4">
                <div class="col-md-3">
                    <div class="card bg-success text-white">
                        <div class="card-body">
                            <h3 class="mb-0">${unanimousEmotions.length}</h3>
                            <small>Unanimous</small>
                        </div>
                    </div>
                </div>
                <div class="col-md-3">
                    <div class="card bg-warning text-white">
                        <div class="card-body">
                            <h3 class="mb-0">${partialEmotions.length}</h3>
                            <small>Partial Agreement</small>
                        </div>
                    </div>
                </div>
                <div class="col-md-3">
                    <div class="card bg-danger text-white">
                        <div class="card-body">
                            <h3 class="mb-0">${singleEmotions.length}</h3>
                            <small>Single Model Only</small>
                        </div>
                    </div>
                </div>
                <div class="col-md-3">
                    <div class="card bg-info text-white">
                        <div class="card-body">
                            <h3 class="mb-0">${((unanimousEmotions.length / Math.max(Object.keys(emotionAgreement).length, 1)) * 100).toFixed(0)}%</h3>
                            <small>Agreement Rate</small>
                        </div>
                    </div>
                </div>
            </div>

            <h6 class="mt-4">Detailed Emotion Agreement:</h6>
            <div class="table-responsive">
                <table class="table table-sm">
                    <thead>
                        <tr>
                            <th>Emotion</th>
                            <th>Agreement</th>
                            <th>Models</th>
                            <th>Avg Confidence</th>
                            <th>Confidence Range</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${Object.entries(emotionAgreement)
                            .sort((a, b) => b[1].count - a[1].count)
                            .map(([emotion, info]) => {
                                const agreementLevel = info.count === modelCount ? 'success' :
                                                      info.count > 1 ? 'warning' : 'danger';
                                const avgScore = info.scores.reduce((a, b) => a + b, 0) / info.scores.length;
                                const minScore = Math.min(...info.scores);
                                const maxScore = Math.max(...info.scores);
                                const variance = info.scores.length > 1 ?
                                    Math.sqrt(info.scores.reduce((sum, s) => sum + Math.pow(s - avgScore, 2), 0) / info.scores.length) : 0;

                                return `
                                    <tr class="table-${agreementLevel}">
                                        <td><strong>${emotion}</strong></td>
                                        <td>
                                            <span class="badge bg-${agreementLevel}">${info.count}/${modelCount} models</span>
                                        </td>
                                        <td>
                                            <small>${info.models.map(m => m.toUpperCase()).join(', ')}</small>
                                        </td>
                                        <td>
                                            <div class="d-flex align-items-center">
                                                <span class="me-2">${(avgScore * 100).toFixed(1)}%</span>
                                                <div class="confidence-indicator">
                                                    <div class="confidence-bar" style="width: ${avgScore * 100}%"></div>
                                                </div>
                                            </div>
                                        </td>
                                        <td>
                                            <small>${(minScore * 100).toFixed(1)}% - ${(maxScore * 100).toFixed(1)}%
                                            ${variance > 0.1 ? '<i class="fas fa-exclamation-triangle text-warning" title="High variance"></i>' : ''}
                                            </small>
                                        </td>
                                    </tr>
                                `;
                            }).join('')}
                    </tbody>
                </table>
            </div>

            <div class="mt-3">
                <h6>Prediction Reliability Insights:</h6>
                <ul>
                    ${unanimousEmotions.length > 0 ?
                        `<li><strong>High Confidence:</strong> All models agree on: ${unanimousEmotions.map(([e]) => e).join(', ')}</li>` : ''}
                    ${partialEmotions.length > 0 ?
                        `<li><strong>Moderate Confidence:</strong> Some models detected: ${partialEmotions.map(([e]) => e).join(', ')}</li>` : ''}
                    ${singleEmotions.length > 0 ?
                        `<li><strong>Low Confidence:</strong> Only one model detected: ${singleEmotions.map(([e]) => e).join(', ')} - may be false positives</li>` : ''}
                    ${Object.keys(emotionAgreement).length === 0 ?
                        '<li class="text-muted">No emotions were detected above threshold by any model</li>' : ''}
                </ul>
            </div>
        `;

        agreementDiv.html(summaryHtml);
    }

    function displayLSTMEmbeddingComparisonPrediction(data) {
        // Check if we have multiple LSTM models (include both lstm and lstm_* variants)
        const lstmModels = Object.keys(data).filter(k => k === 'lstm' || k.startsWith('lstm_'));

        if (lstmModels.length <= 1) {
            $('#lstmEmbeddingCard').hide();
            return;
        }

        $('#lstmEmbeddingCard').show();

        const comparisonDiv = $('#lstmEmbeddingComparison');
        comparisonDiv.empty();

        // Create a table comparing LSTM embeddings
        const table = $('<table class="table table-bordered table-hover"></table>');
        const thead = $('<thead class="table-dark"><tr><th>Emotion</th></tr></thead>');

        // Add embedding type columns
        const embeddingNames = {
            'lstm': 'Learned',
            'lstm_fasttext': 'FastText',
            'lstm_glove': 'GloVe',
            'lstm_tfidf': 'TF-IDF'
        };

        lstmModels.forEach(model => {
            thead.find('tr').append(`<th>${embeddingNames[model] || model.toUpperCase()}</th>`);
        });
        table.append(thead);

        // Get all predicted emotions across LSTM models
        const allEmotions = new Set();
        lstmModels.forEach(model => {
            data[model].predicted_emotions.forEach(e => allEmotions.add(e));
        });

        // If no emotions predicted, show message
        if (allEmotions.size === 0) {
            comparisonDiv.append('<p class="text-muted">No emotions detected above threshold by any LSTM model</p>');
            return;
        }

        const tbody = $('<tbody></tbody>');

        // Add rows for each emotion
        Array.from(allEmotions).sort().forEach(emotion => {
            const row = $(`<tr><td><strong>${emotion}</strong></td></tr>`);

            lstmModels.forEach(model => {
                const score = data[model].all_scores[emotion];
                const isPredicted = data[model].predicted_emotions.includes(emotion);
                const cellClass = isPredicted ? 'table-success' : '';
                const badge = isPredicted ? ' <span class="badge bg-success">âœ“</span>' : '';
                row.append(`<td class="${cellClass}">${(score * 100).toFixed(2)}%${badge}</td>`);
            });

            tbody.append(row);
        });

        table.append(tbody);
        comparisonDiv.append(table);

        // Add statistics
        const statsDiv = $('<div class="mt-3"></div>');
        statsDiv.append('<h6>Embedding Comparison Statistics:</h6>');
        const statsList = $('<ul></ul>');

        lstmModels.forEach(model => {
            const modelName = embeddingNames[model] || model.toUpperCase();
            const predCount = data[model].predicted_emotions.length;
            const topEmotion = Object.entries(data[model].all_scores)
                .sort((a, b) => b[1] - a[1])[0];

            statsList.append(`
                <li><strong>${modelName}:</strong>
                    ${predCount} emotion${predCount !== 1 ? 's' : ''} detected |
                    Top prediction: ${topEmotion[0]} (${(topEmotion[1] * 100).toFixed(1)}%)
                </li>
            `);
        });

        statsDiv.append(statsList);
        comparisonDiv.append(statsDiv);

        // Add insight about differences
        const uniquePredictions = {};
        lstmModels.forEach(model => {
            data[model].predicted_emotions.forEach(emotion => {
                if (!uniquePredictions[emotion]) {
                    uniquePredictions[emotion] = [];
                }
                uniquePredictions[emotion].push(embeddingNames[model] || model);
            });
        });

        const consensusEmotions = Object.entries(uniquePredictions)
            .filter(([_, models]) => models.length === lstmModels.length)
            .map(([emotion]) => emotion);

        const divergentEmotions = Object.entries(uniquePredictions)
            .filter(([_, models]) => models.length < lstmModels.length && models.length > 0)
            .map(([emotion, models]) => ({ emotion, models }));

        if (consensusEmotions.length > 0 || divergentEmotions.length > 0) {
            const insightDiv = $('<div class="alert alert-info mt-3"></div>');
            let insightHtml = '<h6><i class="fas fa-lightbulb"></i> Embedding Analysis:</h6><ul>';

            if (consensusEmotions.length > 0) {
                insightHtml += `<li><strong>Universal Agreement:</strong> All embedding types agree on: ${consensusEmotions.join(', ')}</li>`;
            }

            if (divergentEmotions.length > 0) {
                insightHtml += '<li><strong>Embedding-Specific Predictions:</strong><ul>';
                divergentEmotions.forEach(({ emotion, models }) => {
                    insightHtml += `<li>${emotion}: detected by ${models.join(', ')}</li>`;
                });
                insightHtml += '</ul></li>';
            }

            insightHtml += '<li><strong>Interpretation:</strong> Differences across embeddings reveal how semantic representations affect emotion detection. Pre-trained embeddings (FastText, GloVe) capture broader linguistic patterns, while learned embeddings specialize for this task.</li>';

            insightHtml += '</ul>';
            insightDiv.html(insightHtml);
            comparisonDiv.append(insightDiv);
        }
    }

    // Hybrid variant handling for predictions
    let hybridVariantsData = null;

    function loadHybridVariantsForPredict() {
        $.ajax({
            url: '/api/get-hybrid-variants',
            method: 'GET',
            success: function(groups) {
                hybridVariantsData = groups;
                setupHybridVariantSelector(groups);
            },
            error: function(xhr) {
                console.error('Error loading hybrid variants:', xhr);
            }
        });
    }

    function setupHybridVariantSelector(groups) {
        // Handle ablation category button clicks using delegation
        $('body').off('click', '#predict-ablation-type-buttons button').on('click', '#predict-ablation-type-buttons button', function() {
            const ablationType = $(this).data('ablation');

            // Update active button
            $('#predict-ablation-type-buttons button').removeClass('active');
            $(this).addClass('active');

            if (ablationType === 'cnn_bilstm_attention') {
                // Back to baseline - hide variant buttons
                $('#predict-variant-buttons-container').hide();

                // Switch back to baseline variant in display (already loaded from initial prediction)
                if (currentPredictions['cnn_bilstm_attention']) {
                    updateCNNBiLSTMDisplay('cnn_bilstm_attention', currentPredictions['cnn_bilstm_attention']);
                }
            } else {
                // Show variant buttons container
                $('#predict-variant-buttons-container').show();

                // Populate variant buttons
                const variantButtonsDiv = $('#predict-variant-buttons');
                variantButtonsDiv.empty();

                const group = groups[ablationType];
                if (group && group.variants) {
                    group.variants.sort((a, b) => a.number - b.number).forEach(variant => {
                        const button = $(`
                            <button type="button" class="btn btn-sm btn-outline-success text-start variant-select-btn" data-variant="${variant.model_key}">
                                <strong>#${variant.number.toString().padStart(2, '0')}</strong> - ${variant.description}
                            </button>
                        `);
                        variantButtonsDiv.append(button);
                    });

                    // Attach click handlers to variant buttons using delegation
                    $('body').off('click', '.variant-select-btn').on('click', '.variant-select-btn', function() {
                        const variantKey = $(this).data('variant');

                        // Update active state
                        $('.variant-select-btn').removeClass('active');
                        $(this).addClass('active');

                        // Load variant predictions
                        switchCNNBiLSTMVariant(variantKey);
                    });
                }
            }
        });
    }

    function switchCNNBiLSTMVariant(variantKey) {
        if (!currentText) return;

        // Show loading indicator only on the results section (not the selector)
        const predictedDiv = $('#cnn_bilstm_attention-predicted');
        const topDiv = $('#cnn_bilstm_attention-top');
        const chartDiv = $('#cnn_bilstm_attention-chart');
        const wordImportanceDiv = $('#cnn_bilstm_attention-word-importance');

        // Store original content of each section
        const originalPredicted = predictedDiv.html();
        const originalTop = topDiv.html();

        // Show loading spinner in predicted section
        predictedDiv.html(`
            <div class="text-center py-3">
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
                <p class="mt-2 text-muted small">Loading variant predictions...</p>
            </div>
        `);
        topDiv.empty();
        chartDiv.empty();
        if (wordImportanceDiv.length) wordImportanceDiv.empty();

        console.log(`[Frontend] Requesting prediction for variant ${variantKey}`);

        // Make API call to get predictions for this specific variant only
        $.ajax({
            url: '/api/predict',
            method: 'POST',
            contentType: 'application/json',
            data: JSON.stringify({ text: currentText, model: variantKey }),
            success: function(data) {
                console.log(`[Frontend] Received prediction for variant ${variantKey}`);

                if (data[variantKey]) {
                    updateCNNBiLSTMDisplay(variantKey, data[variantKey]);
                } else {
                    // Restore original content on failure
                    predictedDiv.html(originalPredicted);
                    topDiv.html(originalTop);
                    alert(`Variant ${variantKey} not available`);
                }
            },
            error: function(xhr) {
                console.error(`[Frontend] Error loading variant ${variantKey}:`, xhr);
                // Restore original content on error
                predictedDiv.html(originalPredicted);
                topDiv.html(originalTop);
                alert('Error: ' + (xhr.responseJSON?.error || 'Unknown error'));
            }
        });
    }

    function updateCNNBiLSTMDisplay(modelName, modelData) {
        const emotionColors = {
            'admiration': '#1976d2', 'amusement': '#f57c00', 'anger': '#c62828',
            'annoyance': '#c2185b', 'approval': '#388e3c', 'caring': '#7b1fa2',
            'confusion': '#f9a825', 'curiosity': '#00796b', 'desire': '#ad1457',
            'disappointment': '#5d4037', 'disapproval': '#d84315', 'disgust': '#303f9f',
            'embarrassment': '#b71c1c', 'excitement': '#f57f17', 'fear': '#4e342e',
            'gratitude': '#2e7d32', 'grief': '#455a64', 'joy': '#f9a825',
            'love': '#c2185b', 'nervousness': '#512da8', 'optimism': '#0277bd',
            'pride': '#558b2f', 'realization': '#e65100', 'relief': '#689f38',
            'remorse': '#bf360c', 'sadness': '#37474f', 'surprise': '#f57f17',
            'neutral': '#546e7a'
        };

        // Update predicted emotions
        const predictedDiv = $('#cnn_bilstm_attention-predicted');
        predictedDiv.empty();

        if (modelData.predicted_emotions.length === 0) {
            predictedDiv.append('<p class="text-muted">No emotions detected above threshold</p>');
        } else {
            modelData.predicted_emotions.forEach(emotion => {
                const score = modelData.all_scores[emotion];
                const color = emotionColors[emotion] || '#666';
                predictedDiv.append(`
                    <span class="emotion-tag" style="background-color: ${color}20; color: ${color}; border: 2px solid ${color};">
                        ${emotion} (${(score * 100).toFixed(1)}%)
                    </span>
                `);
            });
        }

        // Update threshold
        $('#cnn_bilstm_attention-threshold').text(modelData.threshold);

        // Update top 5 emotions
        const topDiv = $('#cnn_bilstm_attention-top');
        topDiv.empty();
        const topList = $('<ul class="list-group"></ul>');

        Object.entries(modelData.top_emotions).forEach(([emotion, score]) => {
            const color = emotionColors[emotion] || '#666';
            topList.append(`
                <li class="list-group-item d-flex justify-content-between align-items-center">
                    <span>${emotion}</span>
                    <span class="badge rounded-pill" style="background-color: ${color};">
                        ${(score * 100).toFixed(2)}%
                    </span>
                </li>
            `);
        });
        topDiv.append(topList);

        // Update chart
        const emotions = Object.keys(modelData.all_scores);
        const scores = Object.values(modelData.all_scores);
        const colors = emotions.map(e => emotionColors[e] || '#666');

        const trace = {
            x: emotions,
            y: scores,
            type: 'bar',
            marker: { color: colors }
        };

        const layout = {
            title: 'All Emotion Probabilities',
            xaxis: { tickangle: -45 },
            yaxis: { title: 'Probability', range: [0, 1] },
            height: 400
        };

        Plotly.newPlot('cnn_bilstm_attention-chart', [trace], layout);

        // Update word importance
        visualizeWordImportanceWithLIME(modelName, modelData);

        // Update current predictions and refresh comparison
        currentPredictions[modelName] = modelData;
        createComparisonTable(currentPredictions);
    }
</script>
{% endblock %}

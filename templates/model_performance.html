{% extends "base.html" %}

{% block title %}Model Performance - GoEmotions{% endblock %}

{% block content %}
<!-- Page Header -->
<div class="page-header">
    <h1><i class="fas fa-chart-line"></i> Model Performance</h1>
    <p>Evaluate and compare performance metrics for all trained models</p>
</div>

<!-- Model Selection -->
<div class="content-section">
    <h4 class="section-title">
        <i class="fas fa-cog"></i> Select Model to Evaluate
    </h4>

    <div class="btn-group flex-wrap" role="group">
        {% for model in models %}
        <button
            type="button"
            class="btn btn-outline-primary evaluate-btn"
            data-model="{{ model }}"
        >
            <i class="fas fa-robot"></i> {{ model|upper }}
        </button>
        {% endfor %}
       
    </div>

    <div class="mt-3">
        <p class="text-muted mb-0">
            <i class="fas fa-info-circle"></i>
            Click on a model to evaluate its performance on the test dataset.
            This may take a few moments to compute.
        </p>
    </div>
</div>

<!-- Loading -->
<div class="loading" id="loading" style="display: none;">
    <div class="spinner"></div>
    <p class="mt-3">Evaluating model... This may take a minute.</p>
</div>

<!-- Results Container -->
<div id="resultsContainer"></div>

<!-- LSTM Embedding Comparison Section -->
<div id="lstmEmbeddingSection" style="display: none;">
    <div class="content-section">
        <h4 class="section-title">
            <i class="fas fa-layer-group"></i> LSTM Embedding Type Comparison
        </h4>
        <p class="text-muted">
            Comparing LSTM models with different embedding strategies: Learned (trainable), FastText, GloVe, and TF-IDF.
        </p>

        <div class="row mt-4">
            <div class="col-12">
                <div id="lstmEmbeddingChart"></div>
            </div>
        </div>

        <div class="row mt-4">
            <div class="col-12">
                <h5>Embedding Comparison Table</h5>
                <div class="table-responsive">
                    <table class="table table-striped table-hover" id="lstmEmbeddingTable">
                        <thead class="table-dark">
                            <tr>
                                <th>Embedding Type</th>
                                <th data-bs-toggle="tooltip" data-bs-placement="top"
                                    title="Fraction of incorrectly predicted labels. Lower is better. Measures overall label-level accuracy across all samples.">
                                    Hamming Loss ↓ <i class="fas fa-info-circle" style="font-size: 0.8rem;"></i>
                                </th>
                                <th data-bs-toggle="tooltip" data-bs-placement="top"
                                    title="Area Under ROC Curve (macro-averaged). Higher is better. Measures model's ability to distinguish between positive and negative classes for each emotion.">
                                    AUC-ROC ↑ <i class="fas fa-info-circle" style="font-size: 0.8rem;"></i>
                                </th>
                                <th data-bs-toggle="tooltip" data-bs-placement="top"
                                    title="Micro-averaged F1 score. Higher is better. Harmonic mean of precision and recall weighted by label frequency (favors common emotions).">
                                    F1-Micro ↑ <i class="fas fa-info-circle" style="font-size: 0.8rem;"></i>
                                </th>
                                <th data-bs-toggle="tooltip" data-bs-placement="top"
                                    title="Macro-averaged F1 score. Higher is better. Unweighted average F1 across all emotions (treats rare emotions equally with common ones).">
                                    F1-Macro ↑ <i class="fas fa-info-circle" style="font-size: 0.8rem;"></i>
                                </th>
                                <th data-bs-toggle="tooltip" data-bs-placement="top"
                                    title="Micro-averaged Precision. Higher is better. Of all predicted positive labels, what fraction were correct? Weighted by label frequency.">
                                    Precision-Micro ↑ <i class="fas fa-info-circle" style="font-size: 0.8rem;"></i>
                                </th>
                                <th data-bs-toggle="tooltip" data-bs-placement="top"
                                    title="Micro-averaged Recall. Higher is better. Of all actual positive labels, what fraction were predicted? Weighted by label frequency.">
                                    Recall-Micro ↑ <i class="fas fa-info-circle" style="font-size: 0.8rem;"></i>
                                </th>
                                <th data-bs-toggle="tooltip" data-bs-placement="top"
                                    title="Macro-averaged Precision. Higher is better. Of all predicted positive labels, what fraction were correct? Treats all emotions equally.">
                                    Precision-Macro ↑ <i class="fas fa-info-circle" style="font-size: 0.8rem;"></i>
                                </th>
                                <th data-bs-toggle="tooltip" data-bs-placement="top"
                                    title="Macro-averaged Recall. Higher is better. Of all actual positive labels, what fraction were predicted? Treats all emotions equally.">
                                    Recall-Macro ↑ <i class="fas fa-info-circle" style="font-size: 0.8rem;"></i>
                                </th>
                            </tr>
                        </thead>
                        <tbody id="lstmEmbeddingTableBody"></tbody>
                    </table>
                </div>
            </div>
        </div>

        <div class="row mt-4">
            <div class="col-12">
                <h5>Key Insights</h5>
                <div id="lstmInsights" class="alert alert-info"></div>
            </div>
        </div>
    </div>
</div>

<!-- Comparison Section -->
<div id="comparisonSection" style="display: none;">
    <div class="content-section">
        <h4 class="section-title">
            <i class="fas fa-balance-scale"></i> Model Comparison
        </h4>
        <div id="comparisonChart"></div>
    </div>

    <div class="content-section">
        <h4 class="section-title">
            <i class="fas fa-table"></i> Metrics Comparison Table
        </h4>
        <div class="alert alert-info" role="alert">
            <i class="fas fa-info-circle"></i> <strong>About the Metrics:</strong>
            Hover over column headers to see detailed metric definitions.
            <strong>Micro-averaging</strong> weights by label frequency (favors common emotions),
            while <strong>Macro-averaging</strong> treats all emotions equally (better for rare class performance).
        </div>
        <div class="table-responsive">
            <table class="table table-striped" id="comparisonTable">
                <thead>
                    <tr>
                        <th>Model</th>
                        <th data-bs-toggle="tooltip" data-bs-placement="top"
                            title="Fraction of incorrectly predicted labels. Lower is better. Measures overall label-level accuracy across all samples.">
                            Hamming Loss ↓ <i class="fas fa-info-circle text-muted" style="font-size: 0.8rem;"></i>
                        </th>
                        <th data-bs-toggle="tooltip" data-bs-placement="top"
                            title="Area Under ROC Curve (macro-averaged). Higher is better. Measures model's ability to distinguish between positive and negative classes for each emotion.">
                            AUC-ROC ↑ <i class="fas fa-info-circle text-muted" style="font-size: 0.8rem;"></i>
                        </th>
                        <th data-bs-toggle="tooltip" data-bs-placement="top"
                            title="Micro-averaged F1 score. Higher is better. Harmonic mean of precision and recall weighted by label frequency (favors common emotions).">
                            F1-Micro ↑ <i class="fas fa-info-circle text-muted" style="font-size: 0.8rem;"></i>
                        </th>
                        <th data-bs-toggle="tooltip" data-bs-placement="top"
                            title="Macro-averaged F1 score. Higher is better. Unweighted average F1 across all emotions (treats rare emotions equally with common ones).">
                            F1-Macro ↑ <i class="fas fa-info-circle text-muted" style="font-size: 0.8rem;"></i>
                        </th>
                        <th data-bs-toggle="tooltip" data-bs-placement="top"
                            title="Micro-averaged Precision. Higher is better. Of all predicted positive labels, what fraction were correct? Weighted by label frequency.">
                            Precision-Micro ↑ <i class="fas fa-info-circle text-muted" style="font-size: 0.8rem;"></i>
                        </th>
                        <th data-bs-toggle="tooltip" data-bs-placement="top"
                            title="Micro-averaged Recall. Higher is better. Of all actual positive labels, what fraction were predicted? Weighted by label frequency.">
                            Recall-Micro ↑ <i class="fas fa-info-circle text-muted" style="font-size: 0.8rem;"></i>
                        </th>
                    </tr>
                </thead>
                <tbody id="comparisonTableBody"></tbody>
            </table>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
    // Initialize Bootstrap tooltips
    $(document).ready(function() {
        var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
        var tooltipList = tooltipTriggerList.map(function (tooltipTriggerEl) {
            return new bootstrap.Tooltip(tooltipTriggerEl);
        });
    });

    let allResults = {};

    // Evaluate single model
    $('.evaluate-btn').click(function() {
        const modelName = $(this).data('model');
        evaluateModel(modelName);
    });

    // Evaluate all models
    $('#evaluateAllBtn').click(function() {
        allResults = {};
        $('#loading').show();
        $('#resultsContainer').empty();
        $('#comparisonSection').hide();
        $('#lstmEmbeddingSection').hide();

        const models = {{ models|tojson }};
        let completed = 0;

        models.forEach(model => {
            $.ajax({
                url: `/api/evaluate-model/${model}`,
                method: 'POST',
                contentType: 'application/json',
                data: JSON.stringify({}),
                success: function(data) {
                    allResults[model] = data;
                    completed++;

                    if (completed === models.length) {
                        $('#loading').hide();
                        displayAllResults();
                        displayComparison();
                    }
                },
                error: function(xhr) {
                    alert(`Error evaluating ${model}: ${xhr.responseJSON?.error || 'Unknown error'}`);
                    $('#loading').hide();
                }
            });
        });
    });

    // Show LSTM embedding comparison
    function showLSTMEmbeddingComparison() {
        $('#loading').show();
        $('#resultsContainer').empty();
        $('#comparisonSection').hide();
        $('#lstmEmbeddingSection').hide();

        $.ajax({
            url: '/api/compare-lstm-embeddings',
            method: 'POST',
            contentType: 'application/json',
            data: JSON.stringify({}),
            success: function(data) {
                $('#loading').hide();
                displayLSTMEmbeddingComparison(data);
            },
            error: function(xhr) {
                alert('Error comparing LSTM embeddings: ' + (xhr.responseJSON?.error || 'Unknown error'));
                $('#loading').hide();
            }
        });
    }

    function evaluateModel(modelName) {
        $('#loading').show();

        // Check if this is a hybrid variant - if so, preserve the explorer
        const isHybridVariant = modelName.startsWith('hybrid_');
        const explorerHtml = isHybridVariant ? $('#hybrid-explorer-container').prop('outerHTML') : null;

        $('#resultsContainer').empty();

        // Hide LSTM embedding section for non-LSTM models (only show for simple LSTM)
        if (modelName !== 'lstm') {
            $('#lstmEmbeddingSection').hide();
        }

        $.ajax({
            url: `/api/evaluate-model/${modelName}`,
            method: 'POST',
            contentType: 'application/json',
            data: JSON.stringify({}),
            success: function(data) {
                allResults[modelName] = data;
                $('#loading').hide();
                displayModelResults(data);

                // If this was a hybrid variant and we saved the explorer, restore it
                if (isHybridVariant && explorerHtml && hybridVariantGroups) {
                    $('#resultsContainer').append(explorerHtml);
                    // Reattach event handlers
                    setupHybridFilters(hybridVariantGroups);
                    // Redisplay the variant list to reattach view button handlers
                    const currentFilter = $('#filter-ablation-type').val() || 'all';
                    displayHybridVariantsList(hybridVariantGroups, currentFilter);
                }

                if (Object.keys(allResults).length > 1) {
                    displayComparison();
                }
            },
            error: function(xhr) {
                alert('Error: ' + (xhr.responseJSON?.error || 'Unknown error'));
                $('#loading').hide();
            }
        });
    }

    // Store hybrid variant groups globally
    let hybridVariantGroups = null;

    function displayModelResults(data) {
        // Add embedding selector for LSTM
        const isLSTM = data.model === 'lstm';
        const isCNNBiLSTM = data.model === 'cnn_bilstm_attention';

        const embeddingSelector = isLSTM ? `
            <div class="alert alert-info mt-3">
                <h6><i class="fas fa-layer-group"></i> Try Other Embeddings:</h6>
                <p class="mb-2">Compare LSTM performance with different embedding strategies:</p>
                <div class="btn-group" role="group">
                    <button type="button" class="btn btn-sm btn-outline-primary active" data-embedding="lstm">
                        Learned (Current)
                    </button>
                    <button type="button" class="btn btn-sm btn-outline-primary lstm-embedding-btn" data-embedding="lstm_fasttext">
                        FastText
                    </button>
                    <button type="button" class="btn btn-sm btn-outline-primary lstm-embedding-btn" data-embedding="lstm_glove">
                        GloVe
                    </button>
                    <button type="button" class="btn btn-sm btn-outline-info" id="compareLSTMEmbeddingsBtn-inline">
                        <i class="fas fa-chart-bar"></i> Compare All
                    </button>
                </div>
            </div>
        ` : '';

        // Hybrid explorer will be added separately after the main card for CNN-BiLSTM

        const resultCard = $(`
            <div class="row mb-4">
                <div class="col-12">
                    <div class="card">
                        <div class="card-body">
                            <h4 class="card-title">
                                <i class="fas fa-robot"></i> ${data.model.toUpperCase()} Model Results
                            </h4>

                            ${embeddingSelector}

                            <!-- Overall Metrics -->
                            <div class="row mt-4">
                                <div class="col-md-3">
                                    <div class="metric-card ${data.metrics.hamming_loss < 0.05 ? 'bg-success text-white' : ''}">
                                        <div class="metric-value">${data.metrics.hamming_loss.toFixed(4)}</div>
                                        <div class="metric-label">Hamming Loss</div>
                                    </div>
                                </div>
                                <div class="col-md-3">
                                    <div class="metric-card ${data.metrics.auc_roc_macro > 0.85 ? 'bg-success text-white' : ''}">
                                        <div class="metric-value">${data.metrics.auc_roc_macro.toFixed(4)}</div>
                                        <div class="metric-label">AUC-ROC (Macro)</div>
                                    </div>
                                </div>
                                <div class="col-md-3">
                                    <div class="metric-card">
                                        <div class="metric-value">${data.metrics.f1_micro.toFixed(4)}</div>
                                        <div class="metric-label">F1-Score (Micro)</div>
                                    </div>
                                </div>
                                <div class="col-md-3">
                                    <div class="metric-card">
                                        <div class="metric-value">${data.metrics.f1_macro.toFixed(4)}</div>
                                        <div class="metric-label">F1-Score (Macro)</div>
                                    </div>
                                </div>
                            </div>

                            <div class="row mt-3">
                                <div class="col-md-4">
                                    <div class="metric-card">
                                        <div class="metric-value">${data.metrics.precision_micro.toFixed(4)}</div>
                                        <div class="metric-label">Precision (Micro)</div>
                                    </div>
                                </div>
                                <div class="col-md-4">
                                    <div class="metric-card">
                                        <div class="metric-value">${data.metrics.precision_macro.toFixed(4)}</div>
                                        <div class="metric-label">Precision (Macro)</div>
                                    </div>
                                </div>
                                <div class="col-md-4">
                                    <div class="metric-card">
                                        <div class="metric-value">${data.metrics.threshold}</div>
                                        <div class="metric-label">Prediction Threshold</div>
                                    </div>
                                </div>
                            </div>

                            <!-- Per-Emotion Metrics -->
                            <div class="mt-4">
                                <h5>Per-Emotion Performance</h5>
                                <div id="perEmotionChart-${data.model}"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        `);

        $('#resultsContainer').append(resultCard);

        // Create per-emotion chart
        createPerEmotionChart(data);

        // Add event handlers for LSTM embedding buttons
        if (data.model === 'lstm') {
            $('.lstm-embedding-btn').click(function() {
                const embeddingModel = $(this).data('embedding');
                $('.lstm-embedding-btn').removeClass('active');
                $(this).addClass('active');
                evaluateModel(embeddingModel);
            });

            $('#compareLSTMEmbeddingsBtn-inline').click(function() {
                showLSTMEmbeddingComparison();
            });
        }

        // Load hybrid variants if CNN-BiLSTM - append as separate card below
        if (data.model === 'cnn_bilstm_attention') {
            loadHybridVariants();
        }
    }

    function getVariantTooltip(variantId) {
        // Comprehensive tooltips explaining each variant's purpose and architectural changes
        const tooltips = {
            '01_cnn_bilstm_attention': '<strong>Baseline Configuration</strong><br/>Full hybrid architecture combining:<br/>• CNN for local feature extraction<br/>• BiLSTM for sequential context<br/>• Attention for importance weighting<br/>This is the reference for ablation comparisons.',

            '02_cnn_bilstm_no_attention': '<strong>Ablation: Remove Attention</strong><br/>Tests attention mechanism contribution by removing it while keeping CNN+BiLSTM.<br/><em>Expected impact:</em> Performance drop if attention helps focus on emotion-bearing words.',

            '03_bilstm_attention_no_cnn': '<strong>Ablation: Remove CNN</strong><br/>Tests CNN contribution by removing convolutional layers.<br/><em>Expected impact:</em> May reduce ability to capture local n-gram patterns.',
            
            '04_bilstm_no_attention': '<strong>Ablation: Remove CNN + Attention</strong><br/>Minimal architecture with only BiLSTM for sequential processing.<br/><em>Expected impact:</em> Largest performance drop as multiple components removed.',

            '05_cnn_only': '<strong>Component Test: CNN Only</strong><br/>Pure CNN architecture without LSTM/Attention.<br/><em>Purpose:</em> Test if convolutional layers alone can capture emotion patterns.',

            '06_lstm_only': '<strong>Component Test: LSTM Only</strong><br/>Simple unidirectional LSTM without CNN/Attention.<br/><em>Purpose:</em> Baseline for sequential processing without bidirectionality.',

            '07_cnn_multikernel': '<strong>Component Test: Enhanced CNN</strong><br/>CNN with larger kernel sizes for broader context windows.<br/><em>Purpose:</em> Test if CNN alone can replace LSTM with proper tuning.',

            '08_hybrid_embedding_random': '<strong>Embedding: Random Initialization</strong><br/>Word embeddings trained from scratch (randomly initialized).<br/><em>Use case:</em> When no pre-trained embeddings available or domain-specific vocabulary.',

            '09_hybrid_embedding_glove': '<strong>Embedding: GloVe (Frozen)</strong><br/>Pre-trained GloVe embeddings, weights frozen during training.<br/><em>Advantage:</em> Fast training, leverages general semantic knowledge.',

            '10_hybrid_embedding_fasttext': '<strong>Embedding: FastText (Frozen)</strong><br/>Pre-trained FastText embeddings with subword information, frozen.<br/><em>Advantage:</em> Better handling of rare words and typos.',

            '11_hybrid_embedding_glove_tuned': '<strong>Embedding: GloVe (Fine-tuned)</strong><br/>Pre-trained GloVe embeddings, fine-tuned during training.<br/><em>Advantage:</em> Adapts embeddings to emotion-specific context.',

            '12_hybrid_embedding_fasttext_tuned': '<strong>Embedding: FastText (Fine-tuned)</strong><br/>Pre-trained FastText embeddings, fine-tuned during training.<br/><em>Expected:</em> Best of both - general knowledge + task adaptation.',

            '13_regularization_dropout_only': '<strong>Regularization: Dropout Baseline</strong><br/>Standard dropout (0.3-0.5) without other regularization.<br/><em>Baseline:</em> Most common regularization approach.',

            '14_regularization_batchnorm': '<strong>Regularization: + BatchNormalization</strong><br/>Adds batch normalization to stabilize training.<br/><em>Effect:</em> Can speed up convergence and reduce internal covariate shift.',

            '15_regularization_l2_weak': '<strong>Regularization: + L2 (λ=0.0001)</strong><br/>Weak L2 weight penalty to prevent overfitting.<br/><em>Use case:</em> When mild regularization needed.',

            '16_regularization_l2_medium': '<strong>Regularization: + L2 (λ=0.001)</strong><br/>Medium L2 weight penalty for moderate regularization.<br/><em>Most common:</em> Balanced regularization strength.',

            '17_regularization_l2_strong': '<strong>Regularization: + L2 (λ=0.01)</strong><br/>Strong L2 penalty for aggressive regularization.<br/><em>Trade-off:</em> Reduces overfitting but may underfit.',

            '18_regularization_dropout_high': '<strong>Regularization: High Dropout (0.5)</strong><br/>Aggressive dropout rate for strong regularization.<br/><em>Effect:</em> More robust but slower training.',

            '19_regularization_combined': '<strong>Regularization: Kitchen Sink</strong><br/>Combines Dropout + BatchNorm + L2 (0.001).<br/><em>Purpose:</em> Test if multiple techniques stack benefits.',

            '20_reference_proven_baseline': '<strong>Proven Reference</strong><br/>Simplified BiLSTM+Attention without CNN.<br/><em>Purpose:</em> Established architecture for fair comparison with hybrids.'
        };

        return tooltips[variantId] || '<em>Experimental variant - hover for architecture details</em>';
    }

    function loadHybridVariants() {
        // Create the hybrid explorer card with filter controls
        const explorerCard = $(`
            <div class="row mb-4" id="hybrid-explorer-container">
                <div class="col-12">
                    <div class="card border-primary">
                        <div class="card-header bg-primary text-white">
                            <h5 class="mb-0"><i class="fas fa-flask"></i> Ablation Study - Explore 20 Architectural Variants</h5>
                        </div>
                        <div class="card-body">
                            <p class="text-muted mb-3">
                                Systematically compare variants testing different architectural choices.
                                Use the filters below to explore specific configurations.
                            </p>

                            <!-- Filter Controls -->
                            <div class="row g-3 mb-4">
                                <div class="col-md-4">
                                    <label class="form-label"><i class="fas fa-brain"></i> Ablation Type:</label>
                                    <select class="form-select form-select-sm" id="filter-ablation-type">
                                        <option value="all">All Variants (20)</option>
                                        <option value="attention">Attention Mechanism (4)</option>
                                        <option value="components">CNN vs LSTM Components (3)</option>
                                        <option value="embeddings">Embedding Types (5)</option>
                                        <option value="regularization">Regularization (7)</option>
                                        <option value="reference">Reference Baseline (1)</option>
                                    </select>
                                </div>
                                <div class="col-md-4">
                                    <label class="form-label"><i class="fas fa-cog"></i> Configuration:</label>
                                    <select class="form-select form-select-sm" id="filter-configuration">
                                        <option value="all">All Configurations</option>
                                        <option value="with_attention">With Attention</option>
                                        <option value="no_attention">Without Attention</option>
                                        <option value="with_cnn">With CNN</option>
                                        <option value="no_cnn">Without CNN</option>
                                    </select>
                                </div>
                                <div class="col-md-4">
                                    <label class="form-label"><i class="fas fa-sliders-h"></i> Quick Actions:</label>
                                    <div class="btn-group btn-group-sm w-100" role="group">
                                        <button class="btn btn-outline-primary" id="view-all-variants">
                                            <i class="fas fa-list"></i> View All
                                        </button>
                                        <button class="btn btn-outline-success" id="compare-mode">
                                            <i class="fas fa-chart-bar"></i> Compare Mode
                                        </button>
                                    </div>
                                </div>
                            </div>

                            <!-- Filtered Variants Display -->
                            <div id="hybrid-variant-list" class="mt-3">
                                <div class="text-center">
                                    <div class="spinner-border text-primary" role="status">
                                        <span class="visually-hidden">Loading variants...</span>
                                    </div>
                                    <p class="mt-2">Loading ablation study variants...</p>
                                </div>
                            </div>

                            <!-- Comparison Mode Controls (hidden by default) -->
                            <div id="comparison-mode-controls" style="display: none;" class="mt-3 p-3 bg-light rounded">
                                <h6><i class="fas fa-check-square"></i> Select Variants to Compare:</h6>
                                <div id="comparison-checkboxes" class="row g-2"></div>
                                <div class="mt-3">
                                    <button class="btn btn-sm btn-success" id="execute-comparison" disabled>
                                        <i class="fas fa-chart-bar"></i> Compare Selected
                                    </button>
                                    <button class="btn btn-sm btn-secondary" id="cancel-comparison">
                                        <i class="fas fa-times"></i> Cancel
                                    </button>
                                    <span class="ms-2 text-muted" id="comparison-count">0 variants selected</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        `);

        // Append to results container
        $('#resultsContainer').append(explorerCard);

        // Load the variants data
        $.ajax({
            url: '/api/get-hybrid-variants',
            method: 'GET',
            success: function(groups) {
                hybridVariantGroups = groups;
                displayHybridVariantsList(groups);
                setupHybridFilters(groups);
            },
            error: function(xhr) {
                $('#hybrid-variant-list').html('<div class="alert alert-danger">Error loading variants: ' + (xhr.responseJSON?.error || 'Unknown error') + '</div>');
            }
        });
    }

    function displayHybridVariantsList(groups, filterGroup = 'all') {
        const container = $('#hybrid-variant-list');
        container.empty();

        const groupOrder = ['attention', 'components', 'embeddings', 'regularization', 'reference'];
        const allVariants = [];

        // Collect all variants
        groupOrder.forEach(groupKey => {
            const group = groups[groupKey];
            if (!group || group.variants.length === 0) return;

            group.variants.forEach(variant => {
                allVariants.push({ ...variant, groupKey, groupName: group.name });
            });
        });

        // Filter variants based on selected group
        const filteredVariants = filterGroup === 'all'
            ? allVariants
            : allVariants.filter(v => v.groupKey === filterGroup);

        if (filteredVariants.length === 0) {
            container.html('<p class="text-muted">No variants match the current filters.</p>');
            return;
        }

        // Create table view
        const table = $(`
            <div class="table-responsive">
                <table class="table table-hover table-sm">
                    <thead class="table-light">
                        <tr>
                            <th style="width: 60px;">#</th>
                            <th style="width: 150px;">Category</th>
                            <th>Description</th>
                            <th style="width: 120px;">Action</th>
                        </tr>
                    </thead>
                    <tbody id="variant-table-body"></tbody>
                </table>
            </div>
        `);

        container.append(table);
        const tbody = $('#variant-table-body');

        filteredVariants.sort((a, b) => a.number - b.number).forEach(variant => {
            const categoryBadge = {
                'attention': '<span class="badge bg-info">Attention</span>',
                'components': '<span class="badge bg-warning text-dark">Components</span>',
                'embeddings': '<span class="badge bg-success">Embeddings</span>',
                'regularization': '<span class="badge bg-danger">Regularization</span>',
                'reference': '<span class="badge bg-secondary">Reference</span>'
            }[variant.groupKey];

            // Get detailed tooltip for this variant
            const tooltip = getVariantTooltip(variant.id);

            const row = $(`
                <tr class="variant-row" data-variant-key="${variant.model_key}">
                    <td><span class="badge bg-primary">${variant.number.toString().padStart(2, '0')}</span></td>
                    <td>${categoryBadge}</td>
                    <td>
                        <small>${variant.description}</small>
                        <i class="fas fa-info-circle text-primary ms-2"
                           style="cursor: pointer; font-size: 0.9rem;"
                           data-bs-toggle="tooltip"
                           data-bs-placement="right"
                           data-bs-html="true"
                           title="${tooltip}"></i>
                    </td>
                    <td>
                        <button class="btn btn-sm btn-outline-primary view-variant-btn" data-variant-key="${variant.model_key}">
                            <i class="fas fa-eye"></i> View
                        </button>
                    </td>
                </tr>
            `);

            tbody.append(row);
        });

        // Re-initialize tooltips for newly added elements
        var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
        tooltipTriggerList.map(function (tooltipTriggerEl) {
            return new bootstrap.Tooltip(tooltipTriggerEl);
        });

        // Event handlers using delegation - attach to container that persists
        container.off('click', '.view-variant-btn').on('click', '.view-variant-btn', function(e) {
            e.stopPropagation();
            const variantKey = $(this).data('variant-key');
            evaluateModel(variantKey);
        });
    }

    function setupHybridFilters(groups) {
        // Filter by ablation type
        $('#filter-ablation-type').off('change').on('change', function() {
            const filterValue = $(this).val();
            displayHybridVariantsList(groups, filterValue);
        });

        // Filter by configuration
        $('#filter-configuration').off('change').on('change', function() {
            const configFilter = $(this).val();
            applyConfigurationFilter(groups, configFilter);
        });

        // View all button
        $('#view-all-variants').off('click').on('click', function() {
            $('#filter-ablation-type').val('all');
            $('#filter-configuration').val('all');
            displayHybridVariantsList(groups, 'all');
        });

        // Compare mode toggle
        $('#compare-mode').off('click').on('click', function() {
            enterComparisonMode(groups);
        });

        // Cancel comparison
        $('#cancel-comparison').off('click').on('click', function() {
            exitComparisonMode(groups);
        });

        // Execute comparison
        $('#execute-comparison').off('click').on('click', function() {
            executeHybridComparison();
        });
    }

    function applyConfigurationFilter(groups, configFilter) {
        const container = $('#hybrid-variant-list');
        container.empty();

        const groupOrder = ['attention', 'components', 'embeddings', 'regularization', 'reference'];
        const allVariants = [];

        groupOrder.forEach(groupKey => {
            const group = groups[groupKey];
            if (!group || group.variants.length === 0) return;

            group.variants.forEach(variant => {
                allVariants.push({ ...variant, groupKey, groupName: group.name });
            });
        });

        // Apply configuration filter
        let filteredVariants = allVariants;
        if (configFilter === 'with_attention') {
            filteredVariants = allVariants.filter(v =>
                v.description.toLowerCase().includes('attention') &&
                !v.description.toLowerCase().includes('no attention')
            );
        } else if (configFilter === 'no_attention') {
            filteredVariants = allVariants.filter(v =>
                v.description.toLowerCase().includes('no attention') ||
                (v.groupKey !== 'attention' && !v.description.toLowerCase().includes('attention'))
            );
        } else if (configFilter === 'with_cnn') {
            filteredVariants = allVariants.filter(v =>
                v.description.toLowerCase().includes('cnn') &&
                !v.description.toLowerCase().includes('no cnn')
            );
        } else if (configFilter === 'no_cnn') {
            filteredVariants = allVariants.filter(v =>
                v.description.toLowerCase().includes('no cnn') ||
                v.description.toLowerCase().includes('lstm only')
            );
        }

        // Display filtered variants
        if (filteredVariants.length === 0) {
            container.html('<p class="text-muted">No variants match the current configuration filter.</p>');
            return;
        }

        const table = $(`
            <div class="table-responsive">
                <table class="table table-hover table-sm">
                    <thead class="table-light">
                        <tr>
                            <th style="width: 60px;">#</th>
                            <th style="width: 150px;">Category</th>
                            <th>Description</th>
                            <th style="width: 120px;">Action</th>
                        </tr>
                    </thead>
                    <tbody id="variant-table-body"></tbody>
                </table>
            </div>
        `);

        container.append(table);
        const tbody = $('#variant-table-body');

        filteredVariants.sort((a, b) => a.number - b.number).forEach(variant => {
            const categoryBadge = {
                'attention': '<span class="badge bg-info">Attention</span>',
                'components': '<span class="badge bg-warning text-dark">Components</span>',
                'embeddings': '<span class="badge bg-success">Embeddings</span>',
                'regularization': '<span class="badge bg-danger">Regularization</span>',
                'reference': '<span class="badge bg-secondary">Reference</span>'
            }[variant.groupKey];

            // Get detailed tooltip for this variant
            const tooltip = getVariantTooltip(variant.id);

            const row = $(`
                <tr class="variant-row" data-variant-key="${variant.model_key}">
                    <td><span class="badge bg-primary">${variant.number.toString().padStart(2, '0')}</span></td>
                    <td>${categoryBadge}</td>
                    <td>
                        <small>${variant.description}</small>
                        <i class="fas fa-info-circle text-primary ms-2"
                           style="cursor: pointer; font-size: 0.9rem;"
                           data-bs-toggle="tooltip"
                           data-bs-placement="right"
                           data-bs-html="true"
                           title="${tooltip}"></i>
                    </td>
                    <td>
                        <button class="btn btn-sm btn-outline-primary view-variant-btn" data-variant-key="${variant.model_key}">
                            <i class="fas fa-eye"></i> View
                        </button>
                    </td>
                </tr>
            `);

            tbody.append(row);
        });

        // Re-initialize tooltips for newly added elements
        var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
        tooltipTriggerList.map(function (tooltipTriggerEl) {
            return new bootstrap.Tooltip(tooltipTriggerEl);
        });

        $('.view-variant-btn').off('click').on('click', function(e) {
            e.stopPropagation();
            const variantKey = $(this).data('variant-key');
            evaluateModel(variantKey);
        });
    }

    function enterComparisonMode(groups) {
        // Hide normal view, show comparison mode
        $('#hybrid-variant-list').hide();
        $('#comparison-mode-controls').show();

        const checkboxContainer = $('#comparison-checkboxes');
        checkboxContainer.empty();

        const groupOrder = ['attention', 'components', 'embeddings', 'regularization', 'reference'];
        const allVariants = [];

        groupOrder.forEach(groupKey => {
            const group = groups[groupKey];
            if (!group || group.variants.length === 0) return;

            group.variants.forEach(variant => {
                allVariants.push({ ...variant, groupKey, groupName: group.name });
            });
        });

        allVariants.sort((a, b) => a.number - b.number).forEach(variant => {
            const checkbox = $(`
                <div class="col-md-6 col-lg-4">
                    <div class="form-check">
                        <input class="form-check-input comparison-variant-checkbox" type="checkbox" value="${variant.model_key}" id="cmp-${variant.id}">
                        <label class="form-check-label" for="cmp-${variant.id}">
                            <span class="badge bg-primary me-1">${variant.number.toString().padStart(2, '0')}</span>
                            <small>${variant.description}</small>
                        </label>
                    </div>
                </div>
            `);
            checkboxContainer.append(checkbox);
        });

        // Update count on checkbox change
        $('.comparison-variant-checkbox').on('change', function() {
            const count = $('.comparison-variant-checkbox:checked').length;
            $('#comparison-count').text(`${count} variant${count !== 1 ? 's' : ''} selected`);
            $('#execute-comparison').prop('disabled', count < 2);
        });
    }

    function exitComparisonMode(groups) {
        $('#comparison-mode-controls').hide();
        $('#hybrid-variant-list').show();
        $('.comparison-variant-checkbox').prop('checked', false);
    }

    function executeHybridComparison() {
        const selected = $('.comparison-variant-checkbox:checked').map(function() {
            return $(this).val();
        }).get();

        if (selected.length < 2) {
            alert('Please select at least 2 variants to compare');
            return;
        }

        $('#loading').show();
        $('#resultsContainer').empty();
        $('#comparisonSection').hide();
        $('#lstmEmbeddingSection').hide();

        $.ajax({
            url: '/api/compare-hybrid-variants',
            method: 'POST',
            contentType: 'application/json',
            data: JSON.stringify({ variants: selected }),
            success: function(data) {
                $('#loading').hide();
                displayHybridComparison(data);
            },
            error: function(xhr) {
                alert('Error comparing variants: ' + (xhr.responseJSON?.error || 'Unknown error'));
                $('#loading').hide();
            }
        });
    }


    function createPerEmotionChart(data) {
        const emotions = Object.keys(data.per_emotion);
        const f1Scores = emotions.map(e => data.per_emotion[e].f1);
        const precisions = emotions.map(e => data.per_emotion[e].precision);
        const recalls = emotions.map(e => data.per_emotion[e].recall);

        const trace1 = {
            x: emotions,
            y: f1Scores,
            name: 'F1-Score',
            type: 'bar'
        };

        const trace2 = {
            x: emotions,
            y: precisions,
            name: 'Precision',
            type: 'bar'
        };

        const trace3 = {
            x: emotions,
            y: recalls,
            name: 'Recall',
            type: 'bar'
        };

        const layout = {
            title: 'Per-Emotion Metrics',
            xaxis: { tickangle: -45 },
            yaxis: { title: 'Score', range: [0, 1] },
            barmode: 'group',
            height: 500
        };

        Plotly.newPlot(`perEmotionChart-${data.model}`, [trace1, trace2, trace3], layout);
    }

    function displayAllResults() {
        for (const [model, data] of Object.entries(allResults)) {
            displayModelResults(data);
        }
    }

    function displayComparison() {
        $('#comparisonSection').show();

        // Comparison chart
        const models = Object.keys(allResults);
        const metrics = ['hamming_loss', 'auc_roc_macro', 'f1_micro', 'f1_macro'];

        const traces = metrics.map(metric => ({
            x: models.map(m => m.toUpperCase()),
            y: models.map(m => allResults[m].metrics[metric]),
            name: metric.replace(/_/g, ' ').toUpperCase(),
            type: 'bar'
        }));

        const layout = {
            title: 'Model Metrics Comparison',
            xaxis: { title: 'Model' },
            yaxis: { title: 'Score' },
            barmode: 'group',
            height: 400
        };

        Plotly.newPlot('comparisonChart', traces, layout);

        // Comparison table
        const tbody = $('#comparisonTableBody');
        tbody.empty();

        for (const [model, data] of Object.entries(allResults)) {
            const row = $(`
                <tr>
                    <td><strong>${model.toUpperCase()}</strong></td>
                    <td>${data.metrics.hamming_loss.toFixed(4)}</td>
                    <td>${data.metrics.auc_roc_macro.toFixed(4)}</td>
                    <td>${data.metrics.f1_micro.toFixed(4)}</td>
                    <td>${data.metrics.f1_macro.toFixed(4)}</td>
                    <td>${data.metrics.precision_micro.toFixed(4)}</td>
                    <td>${data.metrics.recall_micro.toFixed(4)}</td>
                </tr>
            `);
            tbody.append(row);
        }
    }

    function displayLSTMEmbeddingComparison(data) {
        $('#lstmEmbeddingSection').show();

        const embeddingTypes = [];
        const metricsData = {
            'hamming_loss': [],
            'auc_roc_macro': [],
            'f1_micro': [],
            'f1_macro': [],
            'precision_micro': [],
            'recall_micro': [],
            'precision_macro': [],
            'recall_macro': []
        };

        // Extract data
        for (const [modelName, modelData] of Object.entries(data)) {
            embeddingTypes.push(modelData.embedding_type);
            Object.keys(metricsData).forEach(metric => {
                metricsData[metric].push(modelData.metrics[metric]);
            });
        }

        // Create comparison chart (grouped bar chart)
        const traces = [
            {
                x: embeddingTypes,
                y: metricsData.hamming_loss,
                name: 'Hamming Loss (↓)',
                type: 'bar',
                marker: { color: '#e74c3c' }
            },
            {
                x: embeddingTypes,
                y: metricsData.auc_roc_macro,
                name: 'AUC-ROC (↑)',
                type: 'bar',
                marker: { color: '#3498db' }
            },
            {
                x: embeddingTypes,
                y: metricsData.f1_micro,
                name: 'F1-Micro (↑)',
                type: 'bar',
                marker: { color: '#2ecc71' }
            },
            {
                x: embeddingTypes,
                y: metricsData.f1_macro,
                name: 'F1-Macro (↑)',
                type: 'bar',
                marker: { color: '#f39c12' }
            }
        ];

        const layout = {
            title: 'LSTM Embedding Type Performance Comparison',
            xaxis: { title: 'Embedding Type' },
            yaxis: { title: 'Score', range: [0, 1] },
            barmode: 'group',
            height: 500
        };

        Plotly.newPlot('lstmEmbeddingChart', traces, layout);

        // Create comparison table
        const tbody = $('#lstmEmbeddingTableBody');
        tbody.empty();

        // Find best and worst for each metric
        const metricNames = ['hamming_loss', 'auc_roc_macro', 'f1_micro', 'f1_macro', 'precision_micro', 'recall_micro', 'precision_macro', 'recall_macro'];
        const bestWorst = {};

        metricNames.forEach(metric => {
            const values = Object.values(data).map(d => d.metrics[metric]);
            // For hamming_loss, lower is better. For others, higher is better
            if (metric === 'hamming_loss') {
                bestWorst[metric] = { best: Math.min(...values), worst: Math.max(...values) };
            } else {
                bestWorst[metric] = { best: Math.max(...values), worst: Math.min(...values) };
            }
        });

        for (const [modelName, modelData] of Object.entries(data)) {
            const metrics = modelData.metrics;
            const row = $('<tr></tr>');

            // Embedding type
            row.append(`<td><strong>${modelData.embedding_type}</strong></td>`);

            // Add metrics with highlighting
            metricNames.forEach(metric => {
                const value = metrics[metric];
                const isBest = value === bestWorst[metric].best;
                const isWorst = value === bestWorst[metric].worst;

                let cellClass = '';
                let badge = '';
                if (isBest) {
                    cellClass = 'table-success';
                    badge = ' <span class="badge bg-success">Best</span>';
                } else if (isWorst) {
                    cellClass = 'table-danger';
                    badge = ' <span class="badge bg-danger">Worst</span>';
                }

                row.append(`<td class="${cellClass}">${value.toFixed(4)}${badge}</td>`);
            });

            tbody.append(row);
        }

        // Generate insights
        const insights = generateLSTMInsights(data, bestWorst);
        $('#lstmInsights').html(insights);
    }

    function generateLSTMInsights(data, bestWorst) {
        let insights = '<ul>';

        // Find best overall model
        const f1MacroScores = Object.entries(data).map(([name, d]) => ({
            name: d.embedding_type,
            score: d.metrics.f1_macro
        }));
        const bestModel = f1MacroScores.reduce((max, curr) => curr.score > max.score ? curr : max);

        insights += `<li><strong>Best Overall Performance:</strong> ${bestModel.name} embedding achieves the highest F1-Macro score (${bestModel.score.toFixed(4)}), indicating better performance on rare emotion classes.</li>`;

        // AUC-ROC comparison
        const aucScores = Object.entries(data).map(([name, d]) => ({
            name: d.embedding_type,
            score: d.metrics.auc_roc_macro
        }));
        const bestAUC = aucScores.reduce((max, curr) => curr.score > max.score ? curr : max);
        insights += `<li><strong>Best Discrimination:</strong> ${bestAUC.name} embedding shows the best AUC-ROC (${bestAUC.score.toFixed(4)}), indicating superior ability to distinguish between emotion classes.</li>`;

        // Hamming Loss comparison
        const hammingScores = Object.entries(data).map(([name, d]) => ({
            name: d.embedding_type,
            score: d.metrics.hamming_loss
        }));
        const bestHamming = hammingScores.reduce((min, curr) => curr.score < min.score ? curr : min);
        insights += `<li><strong>Lowest Error Rate:</strong> ${bestHamming.name} embedding has the lowest Hamming Loss (${bestHamming.score.toFixed(4)}), meaning fewer incorrect label predictions.</li>`;

        // Micro vs Macro comparison
        const modelsList = Object.entries(data);
        if (modelsList.length > 0) {
            const avgMicroMacroGaps = modelsList.map(([name, d]) => ({
                name: d.embedding_type,
                gap: d.metrics.f1_micro - d.metrics.f1_macro
            }));
            const minGap = avgMicroMacroGaps.reduce((min, curr) => curr.gap < min.gap ? curr : min);
            insights += `<li><strong>Most Balanced:</strong> ${minGap.name} embedding shows the smallest gap between F1-Micro and F1-Macro (${minGap.gap.toFixed(4)}), indicating more balanced performance across frequent and rare emotions.</li>`;
        }

        // General observations
        insights += '<li><strong>Embedding Comparison:</strong> Pre-trained embeddings (FastText, GloVe) leverage semantic knowledge learned from large corpora, while learned embeddings adapt specifically to emotion classification. TF-IDF provides a simpler frequency-based representation.</li>';

        insights += '</ul>';
        return insights;
    }

    function displayHybridComparison(data) {
        const comparisonCard = $(`
            <div class="row mb-4">
                <div class="col-12">
                    <div class="card border-primary">
                        <div class="card-header bg-primary text-white">
                            <h5 class="mb-0"><i class="fas fa-microscope"></i> Hybrid Variant Comparison</h5>
                        </div>
                        <div class="card-body">
                            <h6>Comparing ${Object.keys(data).length} variants</h6>

                            <!-- Metrics Comparison Table -->
                            <div class="table-responsive mt-3">
                                <table class="table table-striped table-hover">
                                    <thead class="table-dark">
                                        <tr>
                                            <th>Variant</th>
                                            <th>Description</th>
                                            <th>Hamming Loss ↓</th>
                                            <th>AUC-ROC ↑</th>
                                            <th>F1-Micro ↑</th>
                                            <th>F1-Macro ↑</th>
                                        </tr>
                                    </thead>
                                    <tbody id="hybrid-comparison-tbody"></tbody>
                                </table>
                            </div>

                            <!-- Comparison Chart -->
                            <div id="hybrid-comparison-chart" class="mt-4"></div>

                            <!-- Insights -->
                            <div id="hybrid-comparison-insights" class="mt-4"></div>
                        </div>
                    </div>
                </div>
            </div>
        `);

        $('#resultsContainer').append(comparisonCard);

        // Populate table
        const tbody = $('#hybrid-comparison-tbody');
        const variantMetrics = [];

        // Find best/worst for highlighting
        const metricNames = ['hamming_loss', 'auc_roc_macro', 'f1_micro', 'f1_macro'];
        const bestWorst = {};
        metricNames.forEach(metric => {
            const values = Object.values(data).map(d => d.metrics[metric]);
            if (metric === 'hamming_loss') {
                bestWorst[metric] = { best: Math.min(...values), worst: Math.max(...values) };
            } else {
                bestWorst[metric] = { best: Math.max(...values), worst: Math.min(...values) };
            }
        });

        for (const [modelKey, modelData] of Object.entries(data)) {
            // Extract variant info
            const variantId = modelKey.replace('hybrid_', '');
            const variantNum = variantId.split('_')[0];
            const description = hybridVariantGroups ? getVariantDescription(variantId) : variantId;

            const metrics = modelData.metrics;
            variantMetrics.push({ modelKey, variantId, variantNum, description, metrics });

            const row = $('<tr></tr>');
            row.append(`<td><span class="badge bg-primary">${variantNum}</span></td>`);
            row.append(`<td><small>${description}</small></td>`);

            // Add metrics with highlighting
            ['hamming_loss', 'auc_roc_macro', 'f1_micro', 'f1_macro'].forEach(metric => {
                const value = metrics[metric];
                const isBest = value === bestWorst[metric].best;
                const isWorst = value === bestWorst[metric].worst;

                let cellClass = '';
                let badge = '';
                if (isBest) {
                    cellClass = 'table-success';
                    badge = ' <span class="badge bg-success">Best</span>';
                } else if (isWorst) {
                    cellClass = 'table-danger';
                    badge = ' <span class="badge bg-danger">Worst</span>';
                }

                row.append(`<td class="${cellClass}">${value.toFixed(4)}${badge}</td>`);
            });

            tbody.append(row);
        }

        // Create comparison chart
        const traces = [
            {
                x: variantMetrics.map(v => v.variantNum),
                y: variantMetrics.map(v => v.metrics.auc_roc_macro),
                name: 'AUC-ROC',
                type: 'bar',
                marker: { color: '#3498db' }
            },
            {
                x: variantMetrics.map(v => v.variantNum),
                y: variantMetrics.map(v => v.metrics.f1_macro),
                name: 'F1-Macro',
                type: 'bar',
                marker: { color: '#2ecc71' }
            }
        ];

        const layout = {
            title: 'Performance Comparison Across Variants',
            xaxis: { title: 'Variant Number', type: 'category' },
            yaxis: { title: 'Score', range: [0, 1] },
            barmode: 'group',
            height: 400
        };

        Plotly.newPlot('hybrid-comparison-chart', traces, layout);

        // Generate insights
        const insights = generateHybridInsights(variantMetrics, bestWorst);
        $('#hybrid-comparison-insights').html(insights);

        // Recreate the explorer so users can continue exploring
        if (hybridVariantGroups) {
            // Simply call loadHybridVariants again to recreate the full explorer interface
            loadHybridVariants();
        }
    }

    function getVariantDescription(variantId) {
        for (const groupKey in hybridVariantGroups) {
            const group = hybridVariantGroups[groupKey];
            const variant = group.variants.find(v => v.id === variantId);
            if (variant) return variant.description;
        }
        return variantId;
    }

    function generateHybridInsights(variantMetrics, bestWorst) {
        const best = variantMetrics.find(v => v.metrics.f1_macro === bestWorst.f1_macro.best);
        const worst = variantMetrics.find(v => v.metrics.f1_macro === bestWorst.f1_macro.worst);

        let insights = '<div class="alert alert-info">';
        insights += '<h6><i class="fas fa-lightbulb"></i> Key Findings:</h6><ul>';

        insights += `<li><strong>Best Performer:</strong> Variant #${best.variantNum} (${best.description}) with F1-Macro = ${best.metrics.f1_macro.toFixed(4)}</li>`;
        insights += `<li><strong>Weakest Performer:</strong> Variant #${worst.variantNum} (${worst.description}) with F1-Macro = ${worst.metrics.f1_macro.toFixed(4)}</li>`;

        const improvement = ((best.metrics.f1_macro - worst.metrics.f1_macro) / worst.metrics.f1_macro * 100).toFixed(1);
        insights += `<li><strong>Performance Gap:</strong> ${improvement}% improvement from worst to best variant</li>`;

        insights += '<li><strong>Ablation Study Value:</strong> These comparisons reveal which architectural choices (attention, CNN layers, embeddings, regularization) contribute most to emotion classification performance.</li>';

        insights += '</ul></div>';
        return insights;
    }
</script>
{% endblock %}
